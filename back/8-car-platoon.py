from main import *

def car_platoon (learning_method, number_of_rollouts, simulation_steps, K=None):
  A = np.matrix([
  [1,   0,0,   0,0, 0,0,   0,0, 0,0, 0,0, 0,0],
  [0,   1,0.1, 0,0, 0,0,   0,0, 0,0, 0,0, 0,0],
  [0,   0,1,   0,0, 0,0,   0,0, 0,0, 0,0, 0,0],
  [0,   0,0,   1,0.1, 0,0, 0,0, 0,0, 0,0, 0,0],
  [0,   0,0,   0,1,   0,0, 0,0, 0,0, 0,0, 0,0],
  [0, 0,0,   0,0,   1,0.1, 0,0, 0,0, 0,0, 0,0],
  [0, 0,0,   0,0,   0,1,   0,0, 0,0, 0,0, 0,0],
  [0, 0,0,   0,0,   0,0, 1,0.1, 0,0, 0,0, 0,0],
  [0, 0,0,   0,0,   0,0, 0,1,   0,0, 0,0, 0,0],
  [0, 0,0,   0,0,   0,0, 0,0, 1,0.1, 0,0, 0,0],
  [0, 0,0,   0,0,   0,0, 0,0, 0,1,   0,0, 0,0],
  [0, 0,0,   0,0,   0,0, 0,0, 0,0,  1,0.1,0,0],
  [0, 0,0,   0,0,   0,0, 0,0, 0,0,  0,1,  0,0],
  [0, 0,0,   0,0,   0,0, 0,0, 0,0,  0,0,1,0.1],
  [0, 0,0,   0,0,   0,0, 0,0, 0,0,  0,0,  0,1]
  ])
  B = np.matrix([
  [0.1, 0,   0,   0,   0,   0,   0,   0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0.1, -0.1,0,   0,   0,   0,   0,   0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0,   0.1,-0.1, 0,   0,   0,   0,   0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0,   0,  0.1, -0.1, 0,   0,   0,   0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0,   0,   0,   0.1,-0.1, 0,   0,   0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0,   0,   0,   0,   0.1,-0.1, 0,   0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0,   0,   0,   0,   0,  0.1, -0.1, 0],
  [0,   0,   0,   0,   0,   0,   0,   0],
  [0,   0,   0,   0,   0,   0, 0.1,-0.1],
  ])

  eq_err = 1e-2

  #intial state space
  s_min = np.array([[ 19.9],[ 0.9], [-0.1], [ 0.9],[-0.1], [ 0.9], [-0.1], [ 0.9], [-0.1], [ 0.9],[-0.1], [ 0.9], [-0.1], [ 0.9], [-0.1]])
  s_max = np.array([[ 20.1],[ 1.1], [ 0.1], [ 1.1],[ 0.1], [ 1.1], [ 0.1], [ 1.1], [ 0.1], [ 1.1],[ 0.1], [ 1.1], [ 0.1], [ 1.1], [ 0.1]])

  #sample an initial condition for system
  x0 = np.matrix([
                    [random.uniform(s_min[0, 0], s_max[0, 0])], 
                    [random.uniform(s_min[1, 0], s_max[1, 0])],
                    [random.uniform(s_min[2, 0], s_max[2, 0])],
                    [random.uniform(s_min[3, 0], s_max[3, 0])], 
                    [random.uniform(s_min[4, 0], s_max[4, 0])],
                    [random.uniform(s_min[5, 0], s_max[5, 0])],
                    [random.uniform(s_min[6, 0], s_max[6, 0])],
                    [random.uniform(s_min[7, 0], s_max[7, 0])],
                    [random.uniform(s_min[8, 0], s_max[8, 0])],
                    [random.uniform(s_min[9, 0], s_max[9, 0])],
                    [random.uniform(s_min[10, 0], s_max[10, 0])],
                    [random.uniform(s_min[11, 0], s_max[11, 0])],
                    [random.uniform(s_min[12, 0], s_max[12, 0])],
                    [random.uniform(s_min[13, 0], s_max[13, 0])],
                    [random.uniform(s_min[14, 0], s_max[14, 0])],
                  ])
  x0 =  np.matrix([[ 0.1], [-0.1], [-0.1], [-0.1], [-0.1], [-0.1], [ 0.1], [ 0.1], [-0.1], [-0.1], [-0.1], [-0.1], [ 0.1], [ 0.1], [-0.1]])
  x0 += np.matrix([[20], [1], [0], [1], [0], [1], [0], [1], [0], [1], [0], [1], [0], [1], [0]])
  print ("Sampled initial state is:\n {}".format(x0))  

  Q = np.zeros((15, 15), float)
  np.fill_diagonal(Q, 1)

  R = np.zeros((8,8), float)
  np.fill_diagonal(R, .0005)

  x_min = np.array([[18],[0.5],[-1],[0.5],[-1],[0.5],[-1],[0.5],[-1],[0.5],[-1],[0.5],[-1],[0.5],[-1]])
  x_max = np.array([[22],[1.5], [1],[1.5],[ 1],[1.5],[ 1],[1.5], [1],[1.5],[ 1],[1.5],[ 1],[1.5],[ 1]])
  u_min = np.array([[-10.], [-10.], [-10.], [-10.], [-10.], [-10.], [-10.], [-10.]])
  u_max = np.array([[ 10.], [ 10.], [ 10.], [ 10.], [ 10.], [ 10.], [ 10.], [ 10.]])

  #Coordination transformation
  origin = np.array([[20], [1], [0], [1], [0], [1], [0], [1], [0], [1], [0], [1], [0], [1], [0]])
  s_min -= origin
  s_max -= origin
  x0 -= origin
  x_min -= origin
  x_max -= origin

  #Coordination-transformed state space
  S0 = Polyhedron.from_bounds(s_min, s_max)

  if K is None:
    while True:
      K = learn_controller (A, B, Q, R, x0, eq_err, learning_method, number_of_rollouts, simulation_steps, x_min, x_max, explore_mag = 0.1, step_size = 0.5)
      names = {0:"x0", 1:"x1", 2:"x2", 3:"x3", 4:"x4", 5:"x5", 6:"x6", 7:"x7", 8:"x8", 9:"x9", 10:"x10", 11:"x11", 12:"x12", 13:"x13", 14:"x14"}
      draw_controller (A, B, K, x0, simulation_steps*10, names,coordination=origin)
      names = {0:"x0", 1:"x1"}
      O_inf = verify_controller (np.asarray(A), np.asarray(B), np.asarray(K), x_min, x_max, u_min, u_max, names.keys())
      ce = S0.is_included_in_with_ce(O_inf)
      if ce is None:
        print "A verified policy is learned!"
        break
      else:
        print "Is the learned policy working well on the sampled input?: {}".format(O_inf.contains(x0))
        print "An input that is not within the current invariant set:\n {}".format(ce)
        x0 = np.asmatrix(ce)
  else:
    names = {0:"x0", 1:"x1", 2:"x2", 3:"x3", 4:"x4", 5:"x5", 6:"x6", 7:"x7", 8:"x8", 9:"x9", 10:"x10", 11:"x11", 12:"x12", 13:"x13", 14:"x14"}
    draw_controller (A, B, K, x0, simulation_steps, names)
    names = {0:"x0", 1:"x1"}
    O_inf = verify_controller (np.asarray(A), np.asarray(B), np.asarray(K), x_min, x_max, u_min, u_max, names.keys())
    ce = S0.is_included_in_with_ce(O_inf)
    if ce is None:
      print "Control Policy Verified!"
    else:
      print "A counter example is found {}".format(ce)

K = [[-10.08828291,  -5.71863313,   3.87822747,   6.23108424,   8.07515356,
    2.5342523,    9.74450076, -11.34647235,  -2.46038445,   2.0245565,
    4.36642846,  -0.14904112,  -0.9733207,   -6.6804136,    0.07925514],
 [  1.45537151,   2.52329859,   9.58968671,  -5.43473338,  -4.51123665,
    4.43773798,   5.52950575,   0.8810365,   -1.32970901,  -2.94917832,
   -0.92610546,   0.28965067,   8.02637052,  -1.48376198,  -2.12279792],
 [ -1.49649015,  13.37255449,   4.93222631,  10.11971416,  -0.2818263,
    1.81511385,  -5.77129379,   4.31931348,  -2.96976733,   1.84276815,
    1.11145825,   4.18045871,   0.60973379,  -8.42986478,  -2.07267261],
 [  3.10989658,   1.2850494 ,   5.55728762,   2.56011935,   4.80149784,
    4.35187475,   8.86301126,  -0.85437193,  -3.9947828 ,  0.05344002,
   -1.66669898, -11.9223491 ,  -3.55964134,   1.82010321,  -2.00195768],
 [ -1.45805078,   1.32993624,  -0.18906441,  -4.84470242,   0.64251924,
    3.08865669,  -1.1271393 ,  -0.05933599,   3.40017184,  -8.17740996,
   -1.28364022,   1.0952332 ,  -1.19583374,  -1.49557448,   3.27044004],
 [ -6.96462058,   3.61095581,   2.8654995 ,  -2.22813343,   1.37919914,
    0.14975645,   2.79898114,   5.59992402,   5.8308186 ,   3.39717145,
    5.60998568,  -2.94271161,   0.09430217,  -3.96942383,  -6.01282549],
 [  2.14981365,  -3.66424285,  -5.48189946,   1.81297353,  -3.28469716,
   -2.67105179,   3.47756748,   2.37418767,  -2.59560093,   5.06283365,
    2.09480147,  -1.89019356,   7.84274711,  -0.32095752, -13.3066333 ],
 [ -3.91069499,  -3.42995595,   1.60876998,  -7.12554424,   3.92988563,
    3.10663899,   2.37552972,   0.27217519,   7.1755486,    1.95777789,
    4.58775108,   3.59253818,   6.33784418,  -1.27614225,   5.57587042]]
car_platoon("random_search", 100, 200)